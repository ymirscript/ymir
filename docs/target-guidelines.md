# Guidelines for developing Target Plugins
This document sets out some guidelines intended for plugin developers when developing target language plugins. These guidelines are intended to keep the consistency of the generator the same across all target languages, so that switching to another language is easily possible without violating the semantics of the other target language plugins and creating a consistent image.

### 1. Handling of Header and Body Validation Inheritance
Ymir allows adding validations before the actual handlers are called. The Ymir definition language allows to define these validations in 2 different places: A router block or the route itself. The definition of these validations works with the "header" or respectively "body" keyword. If these validations are defined on the route itself, they are only valid for this one route. If a validation is made at the router above, these validations are inherited on the child routes and routers, and here there were to the development of Ymir 2 possibilities of the conversion. Possibility 1, which was not selected, was the general case, special case rule. Here the router describes the general case, which actually always occurs, except a route defines its special case, and thus overwrites the validations defined in the router. The 2nd possibility, which was taken afterwards, was the merging of the validations. If validations are defined on the router as well as on the route, then the union of the two validations must be true, so that a route can be called. This must be considered in the target language plugin!

### 2. Do not override edited code!
This is one of the most important principles of Ymir. Already in the planning of Ymir the concept of the definition language should be that we want to generate boilerplate code which, even if a company uses it and has to change it again later on, even though a lot has already been changed in the boilerplate code, that the changes adapt themselves as good as possible. This is what we call "code adaptation". This is implemented, for example, in the JavaScript module by splitting the routes into unimplemented base classes, which can then be overwritten by inheritance. If routes are changed now, then only the base class is changed, the child class changed by the company or by the developer and the production code changed with it remain untouched.