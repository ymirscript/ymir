import * as pathApi from "https://deno.land/std@0.182.0/path/mod.ts";

import { AuthBlockNode, GlobalVariable, IPluginContext, Logger, MiddlewareNode, MiddlewareOptions, PathNode, PluginBase, RouteNode, RouterNode, AuthType, ProjectNode } from "../../library/mod.ts";

export default class JavaSpringBootTargetPlugin extends PluginBase {

    private _config: TargetConfig = null!;
    private _mainPackagePath: string = null!;
    private _dtoPackagePath: string = null!;
    private _configPackagePath: string = null!;

    public get targetFor(): string | undefined {
        return "Java_SpringBoot";
    }

    public compile(context: IPluginContext): void {
        if (context.indexFile === undefined) {
            return;
        }

        this._config = this.getConfig(context.configuration);
        this._mainPackagePath = this.initializePackagePath(context.outputDirectory, this._config.packages.main);
        this._dtoPackagePath = this.initializePackagePath(this._mainPackagePath, this._config.packages.dto);
        this._configPackagePath = this.initializePackagePath(this._mainPackagePath, this._config.packages.config);
    }

    private initializePackagePath(base: string, packageName: string): string {
        let packagePath = base;

        packageName.split(".").forEach(part => {
            packagePath = pathApi.join(packagePath, part);

            if (!this.doesDirectoryExist(packagePath)) {
                Deno.mkdirSync(packagePath);
            }
        });

        return packagePath;
    }

    private doesDirectoryExist(path: string): boolean {
        try {
            return Deno.statSync(path).isDirectory;
        } catch {
            return false;
        }
    }

    private getConfig(baseConfig: {[key: string]: unknown}): TargetConfig {
        const config: TargetConfig = {
            useSpringSecurity: false,
            packages: {
                main: "com.example",
                dto: "dto",
                config: "config",
            },
        };

        if (baseConfig.useSpringSecurity !== undefined && typeof baseConfig.useSpringSecurity === "boolean") {
            config.useSpringSecurity = baseConfig.useSpringSecurity as boolean;
        }

        if (baseConfig.packages !== undefined && typeof baseConfig.packages === "object") {
            const packages = baseConfig.packages as {[key: string]: string};
            if (packages.main !== undefined && typeof packages.main === "string") {
                config.packages!.main = packages.main;
            }
            if (packages.dto !== undefined && typeof packages.dto === "string") {
                config.packages!.dto = packages.dto;
            }
            if (packages.config !== undefined && typeof packages.config === "string") {
                config.packages!.config = packages.config;
            }
        }

        return config;
    }
}

class ClassBuilder {

    private readonly _imports: string[] = [];
    private readonly _annotations: string[] = [];
    private readonly _methods: MethodBuilder[] = [];

    constructor(
        private _package: string,
        private _name: string,
    ) {}

    public addImport(importPath: string): ClassBuilder {
        this._imports.push(importPath);
        return this;
    }

    public addAnnotation(annotation: string): ClassBuilder {
        this._annotations.push(annotation);
        return this;
    }

    public addMethod(method: MethodBuilder): ClassBuilder {
        this._methods.push(method);
        return this;
    }

    public save(path: string): void {
        const filePath = pathApi.join(path, `${this._name}.java`);

        Deno.writeTextFileSync(filePath, this.toString());
    }

    public toString(): string {
        let result = `package ${this._package};\n\n`;

        this._imports.forEach(importPath => {
            result += `import ${importPath};\n`;
        });

        result += "\n/**\n";
        result += ` * This class was generated by YmirScript. Do not edit it manually.\n`;
        result += " */\n";

        this._annotations.forEach(annotation => {
            result += `@${annotation}\n`;
        });

        result += `public class ${this._name} {\n`;

        this._methods.forEach(method => {
            result += "\n";
            result += method.toString();
        });

        result += "}\n";

        return result;
    }
}

class MethodBuilder {

    private readonly _parameters: ParameterBuilder[] = [];
    private readonly _annotations: string[] = [];
    private readonly _body: string[] = [];

    constructor(
        private _name: string,
        private _returnType: string = "void",
        private _accessModifier: string = "public"
    ) {}

    public addParameter(parameter: ParameterBuilder): MethodBuilder {
        this._parameters.push(parameter);
        return this;
    }

    public addAnnotation(annotation: string): MethodBuilder {
        this._annotations.push(annotation);
        return this;
    }

    public addBodyLine(line: string): MethodBuilder {
        this._body.push(line);
        return this;
    }

    public toString(): string {
        let result = "";

        this._annotations.forEach(annotation => {
            result += `    @${annotation}\n`;
        });

        result += `    ${this._accessModifier} ${this._returnType} ${this._name}(`;

        if (this._parameters.length > 0) {
            this._parameters.forEach((parameter, index) => {
                result += parameter.toString();

                if (index < this._parameters.length - 1) {
                    result += ", ";
                }
            });
        }

        result += ") {\n";

        this._body.forEach(line => {
            result += `        ${line}\n`;
        });

        result += "    }\n";

        return result;
    }
}

class ParameterBuilder {

    private readonly _annotations: string[] = [];
    
    constructor(
        private _name: string,
        private _type: string,
    ) {}

    public addAnnotation(annotation: string): ParameterBuilder {
        this._annotations.push(annotation);
        return this;
    }

    public toString(): string {
        let result = "";

        this._annotations.forEach(annotation => {
            result += `@${annotation} `;
        });

        result += `${this._type} ${this._name}`;

        return result;
    }
}

interface TargetConfig {
    useSpringSecurity: boolean;
    packages: {
        main: string;
        dto: string;
        config: string;
    };
}