import * as pathApi from "https://deno.land/std@0.182.0/path/mod.ts";

import { GlobalVariable, IPluginContext, Logger, MiddlewareNode, MiddlewareOptions, PathNode, PluginBase, RouteNode, RouterNode } from "../../library/mod.ts";

export default class JavaScriptTargetPlugin extends PluginBase {

    private _middlewareHandlers: Map<string, (router: string, node: MiddlewareNode) => string[]> = new Map();
    private _wasEnvUsed = false;
    private _exports: string[] = ["startServer", "errorMessage", "YmirRestBase"];

    public get targetFor(): string | undefined {
        return "JavaScript";
    }

    public compile(context: IPluginContext): void {
        if (context.indexFile === undefined) {
            return;
        }

        this.registerMiddlewareHandler("env", this.envMiddleware.bind(this));
        this.registerMiddlewareHandler("json", this.jsonMiddleware.bind(this));
        this.registerMiddlewareHandler("cors", this.corsMiddleware.bind(this));



        const output = [
            "// --- GENERATED BY YMIR ---",
            "",
            "// needed validation functions",
            "const isInt = (str) => {",
            "    const v = parseInt(str);",
            "    return !isNaN(v) && isFinite(v);",
            "};",
            "const isFloat = (str) => {",
            "    const v = parseFloat(str);",
            "    return !isNaN(v) && isFinite(v);",
            "};",
            "const isBoolean = (str) => {",
            "    return str === \"true\" || str === \"false\";",
            "};",
            "const isDate = (str) => {",
            "    return !isNaN(Date.parse(str));",
            "};",
            "const isDatetime = isDate;",
            "const isTime = isDate;",
            "const isString = (str) => true;",
            "const getHeader = (headers, name) => {",
            "    const header = Object.keys(headers).find(key => key.toLowerCase() === name.toLowerCase());",
            "    return header === undefined ? undefined : headers[header];",
            "};",
            "",
            "const errorMessage = {",
            "    _400: \"Bad Request: Field {field} of type {type} is required\",",
            "    _401: \"Unauthorized: You are not authorized to access this resource\",",
            "    _403: \"Forbidden: You are not allowed to access this resource\",",
            "    _404: \"Not Found: The requested resource could not be found\",",
            "    _500: \"Internal Server Error: An internal server error occurred\",",
            "    Started: \"Server started on port {port}...\",",
            "};",
            "",
            "const express = require(\"express\");",
            "const app = express();",
            ""
        ];

        const [routerOutput, _] = this.handleRouter(context.projectNode, true, "");
        output.push(...routerOutput);

        output.push(...[
            "",
            "const startServer = (runtime) => {",
            "    const ymir = new runtime();",
            "    ymir.build(app);",
            "    app.listen(process.env.PORT || 3000, () => {",
            "        console.log(errorMessage.Started.replace(\"{port}\", process.env.PORT || 3000));",
            "    });",
            "};",
            "",
            `module.exports = {${(this._exports.join(", "))}};`
        ]);

        const outputFile = pathApi.join(context.outputDirectory, "ymir_base.js");

        Deno.writeTextFileSync(outputFile, output.join("\r\n"));
    }

    private handleRouter(routerNode: RouterNode, isApp: boolean, parentName: string): [string[], string[]] {
        const routerName = isApp ? 'app' : routerNode.path.name;
        const output: string[] = [];

        for (const middleware of routerNode.middlewares) {
            const handler = this._middlewareHandlers.get(middleware.name);
            if (handler === undefined) {
                Logger.warning("No handler for middleware \"%s\" found.", middleware.name);
                continue;
            }

            const handlerCode = handler(routerName, middleware);
            if (handlerCode.length <= 0) {
                Logger.debug("WARNING: Handler for middleware \"%s\" returned undefined.", middleware.name);
                continue;
            }

            output.push(...handlerCode);
        }

        if (isApp) {
            output.push(...["", `class YmirRestBase {`]);
        }

        const routerBuildFunctionLines: string[] = [];

        if (routerNode.middlewares.length > 0 && !isApp) {
            routerBuildFunctionLines.push("// Middlewares");

            for (const middleware of routerNode.middlewares) {
                const handler = this._middlewareHandlers.get(middleware.name);
                if (handler === undefined) {
                    Logger.warning("No handler for middleware \"%s\" found.", middleware.name);
                    continue;
                }

                const handlerCode = handler(isApp ? "app" : "router", middleware);
                if (handlerCode.length <= 0) {
                    Logger.debug("WARNING: Handler for middleware \"%s\" returned undefined.", middleware.name);
                    continue;
                }

                routerBuildFunctionLines.push(...handlerCode);
            }
        }

        if (!isApp) {
            routerBuildFunctionLines.push(`const ${routerName} = express.Router();`);

            const validationCode = this.generateValidationCode(routerNode.header, routerNode.body, routerNode.path);
            if (validationCode.length > 0) {
                routerBuildFunctionLines.push(`${routerName}.use((req, res, next) => {`);
                routerBuildFunctionLines.push("    try {");
                routerBuildFunctionLines.push(...validationCode.map((line) => "    " + line));
                routerBuildFunctionLines.push("        next();");
                routerBuildFunctionLines.push("    } catch (e) {");
                routerBuildFunctionLines.push("        next(e);");
                routerBuildFunctionLines.push("    }");
                routerBuildFunctionLines.push("});");
            }

            routerBuildFunctionLines.push(`${parentName}.use("${routerNode.path.path}", ${routerName});`);
        }

        if (routerNode.routers.length > 0) {
            routerBuildFunctionLines.push("// Routers");

            for (const router of routerNode.routers) {
                const [routerCode, routerBuildFunctionLinesInternal] = this.handleRouter(router, false, routerName);
                output.push(...routerCode);
                routerBuildFunctionLines.push(...routerBuildFunctionLinesInternal);
            }
        }

        if (routerNode.routes.length > 0) {
            routerBuildFunctionLines.push("// Routes");
        }

        for (const route of routerNode.routes) {
            const [routeLines, buildFunctionLines] = this.handleRoute(route, routerName);
            output.push(...routeLines.map((line) => "    " + line));
            routerBuildFunctionLines.push(...buildFunctionLines);
        }

        if (isApp) {
            output.push(...[
                "",
                "    build(app) {",
            ]);

            for (const line of routerBuildFunctionLines) {
                output.push(`        ${line}`);
            }

            output.push(...[
                "        app.use((err, req, res, next) => {",
                "            if (err && (res.statusCode === 400)) {",
                "                res.send(err.message);",
                "            } else if (err) {",
                "                res.status(500).send(errorMessage._500);",
                "            } else {",
                "                res.status(404).send(errorMessage._404);",
                "            }",
                "        });",
                "    }",
                "}",
            ]);
        }
        return [output, isApp ? [] : routerBuildFunctionLines];
    }

    private handleRoute(route: RouteNode, routerName: string): [string[], string[]] {
        const output: string[] = [];
        const buildFunctionLines: string[] = [];

        const routeName = route.path.name;
        const handlerName = "on" + (routerName === "" ? "" : routerName.charAt(0).toUpperCase() + routerName.slice(1)) + routeName.charAt(0).toUpperCase() + routeName.slice(1);

        buildFunctionLines.push(`${(routerName === "" ? "app" : routerName)}.${route.method.toLowerCase()}("${route.path.path}", this.${handlerName}.bind(this));`);

        output.push("");
        output.push(`async ${handlerName}(req, res) {`);

        output.push(...this.generateValidationCode(route.header, route.body, route.path));
        output.push(`}`);


        return [output, buildFunctionLines];
    }

    private generateValidationCode(header: MiddlewareOptions|undefined, body: MiddlewareOptions|undefined, path: PathNode): string[] {
        const output: string[] = [];

        if (header !== undefined) {
            output.push(`    if (req.headers === undefined) {`);
            output.push(`        res.status(400);`);
            output.push(`        throw new Error(errorMessage._400.replace("{field}", "header").replace("{type}", "object"));`);
            output.push(`    }`);
            output.push("");
            output.push(`    const header = req.headers;`);

            for (const key in header) {
                if (!(header[key] instanceof Object)) {
                    output.push(`    if (getHeader(header, "${key}") === undefined) {`);
                    output.push(`        res.status(400);`);
                    output.push(`        throw new Error(errorMessage._400.replace("{field}", "header.${key}").replace("{type}", "${header[key]}"));`);
                    output.push(`    }`);
                    // @ts-ignore - we can assume, that the schema value is of string type, cause for schema validation only objects and strings are allowed
                    output.push(`    if (!is${header[key].charAt(0).toUpperCase() + header[key].slice(1)}(getHeader(header, "${key}"))) {`);
                    output.push(`        res.status(400);`);
                    output.push(`        throw new Error(errorMessage._400.replace("{field}", "header.${key}").replace("{type}", "${header[key]}"));`);
                    output.push(`    }`);
                    output.push("");
                }
            }
        }
        
        if (path.queryParameters.length > 0) {
            output.push(`    if (req.query === undefined) {`);
            output.push(`        res.status(400);`);
            output.push(`        throw new Error(errorMessage._400.replace("{field}", "query").replace("{type}", "object"));`);
            output.push(`    }`);
            output.push("");
            output.push(`    const query = req.query;`);

            for (const queryParameter of path.queryParameters) {
                output.push(`    if (query.${queryParameter.name} === undefined) {`);
                output.push(`        res.status(400);`);
                output.push(`        throw new Error(errorMessage._400.replace("{field}", "query.${queryParameter.name}").replace("{type}", "${queryParameter.type}"));`);
                output.push(`    }`);
                output.push(`    if (!is${queryParameter.type.charAt(0).toUpperCase() + queryParameter.type.slice(1)}(query.${queryParameter.name})) {`);
                output.push(`        res.status(400);`);
                output.push(`        throw new Error(errorMessage._400.replace("{field}", "query.${queryParameter.name}").replace("{type}", "${queryParameter.type}"));`);
                output.push(`    }`);
                output.push("");
            }
        }

        if (body !== undefined) {
            output.push(`    if (req.body === undefined) {`);
            output.push(`        res.status(400);`);
            output.push(`        throw new Error(errorMessage._400.replace("{field}", "body").replace("{type}", "object"));`);
            output.push(`    }`);
            output.push("");
            output.push(`    const body = req.body;`);
    
            const bodyValidation = this.generateDeepObjectValidation("body", body);
            output.push(...bodyValidation.map((line) => line));
        }

        return output;
    }

    private generateDeepObjectValidation(objName: string, schema: MiddlewareOptions): string[] {
        const output: string[] = [];

        for (const key in schema) {
            if (schema[key] instanceof Object) {
                output.push(`    if (${objName}["${key}"] === undefined) {`);
                output.push(`        res.status(400);`);
                output.push(`        throw new Error(errorMessage._400.replace("{field}", "${objName}.${key}").replace("{type}", "object"));`);
                output.push(`    }`);
                output.push("");
                output.push(...this.generateDeepObjectValidation(`${objName}.${key}`, schema[key] as MiddlewareOptions));
            } else {
                output.push(`    if (${objName}["${key}"] === undefined) {`);
                output.push(`        res.status(400);`);
                output.push(`        throw new Error(errorMessage._400.replace("{field}", "${objName}.${key}").replace("{type}", "${schema[key]}"));`);
                output.push(`    }`);
                // @ts-ignore - we can assume, that the schema value is of string type, cause for schema validation only objects and strings are allowed
                output.push(`    if (!is${schema[key].charAt(0).toUpperCase() + schema[key].slice(1)}(${objName}["${key}"])) {`);
                output.push(`        res.status(400);`);
                output.push(`        throw new Error(errorMessage._400.replace("{field}", "${objName}.${key}").replace("{type}", "${schema[key]}"));`);
                output.push(`    }`);
                output.push("");
            }
        }

        return output;
    }

    private corsMiddleware(router: string, node: MiddlewareNode): string[] {
        if (node.options === undefined) {
            return [
                `${router}.use(require("cors")());`,
            ];
        }

        let origin = "*";

        if (node.options["origin"] !== undefined) {
            const originOption = node.options["origin"];
            if (originOption instanceof GlobalVariable) {
                if (originOption.path.length > 0 && originOption.path[0] === "env") {
                    origin = `process.env.${originOption.name}`;
                }
            } else {
                origin = "\"" + originOption + "\"";
            }
        }

        return [
            `${router}.use(require("cors")({origin: ${origin}}));`,
        ];
    }

    private jsonMiddleware(router: string, _node: MiddlewareNode): string[] {
        return [
            `${router}.use(express.json());`,
        ];
    }

    private envMiddleware(_router: string, _node: MiddlewareNode): string[] {
        if (!this._wasEnvUsed) {
            this._wasEnvUsed = true;
        }

        return [
            `require("dotenv").config();`,
        ];
    }

    private registerMiddlewareHandler(name: string, handler: (router: string, node: MiddlewareNode) => string[]): void {
        this._middlewareHandlers.set(name, handler);
    }
}