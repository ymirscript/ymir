import * as pathApi from "https://deno.land/std@0.182.0/path/mod.ts";
import { stringify } from "https://deno.land/std@0.182.0/encoding/yaml.ts";

import { AbortError, AuthBlockNode, BearerAuthGenerationMode, IPluginContext, Logger, MiddlewareNode, MiddlewareOptions, PluginBase, ProjectNode, RouteNode, RouterNode } from "../../library/mod.ts";

export default class SwaggerTargetPlugin extends PluginBase {

    private _swagger: SwaggerYaml = null!;
    private _mimeType: string|undefined = undefined;
    private _defaultAuthenticate = false;
    private readonly _existingPaths: {[key: string]: SwaggerRouter } = {};
    private readonly _additionalRoutes: {[key: string]: SwaggerRouter } = {};

    public get targetFor(): string | undefined {
        return "Swagger";
    }

    public compile(context: IPluginContext): void {
        this._swagger = {
            swagger: "2.0",
            info: {
                description: "Autogenerated OpenAPI definition by Ymir",
                title: context.indexFile.filename,
                version: "1.0.0"
            },
            paths: {}
        };

        this.compileProjectNode(context.projectNode);

        for (const key in this._additionalRoutes) {
            this._swagger.paths[key] = this._additionalRoutes[key];
        }

        const outputFile = pathApi.join(context.outputDirectory, "swagger.yml");

        Deno.writeTextFileSync(outputFile, stringify(this._swagger as unknown as Record<string, unknown>, {
            indent: 2
        }));
    }

    private compileProjectNode(node: ProjectNode) {
        node.middlewares.forEach(x => this.handleMiddleware(x));

        Object.values(node.authBlocks).forEach(authBlock => this.compileAuthBlockNode(authBlock));

        if (node.routes.length <= 0) {
            node.routers.forEach(router => this.compileRouterNode(router));
        } else {
            this.compileRouterNode(node);
        }
    }

    private compileRouterNode(node: RouterNode, preTags?: string[], prefixRoute?: string, preAuthenticate?: boolean, preAuthorization?: boolean, preHeaderValidations?: MiddlewareOptions, preBodyValidations?: MiddlewareOptions) {
        const tags = preTags || [];

        if (node.path.name && !tags.includes(node.path.name)) {
            tags.push(node.path.name);
        }

        const authenticate = preAuthenticate || node.authenticate !== undefined || this._defaultAuthenticate;
        const authorization = preAuthorization || node.authenticate?.authorization !== undefined;
        const headerValidations = {...(preHeaderValidations || {}), ...(node.header || {})};
        const bodyValidations = {...(preBodyValidations || {}), ...(node.body || {})};
        
        node.routers.forEach(router => {
            this.compileRouterNode(router, tags, (prefixRoute || "") + router.path.path, authenticate, authorization, headerValidations, bodyValidations);
        });

        node.routes.forEach(route => {
            this.compileRouteNode(route, tags, (prefixRoute || ""), authenticate, authorization, headerValidations, bodyValidations);
        });
    }

    private compileRouteNode(node: RouteNode, preTags?: string[], prefixRoute?: string, preAuthenticate?: boolean, preAuthorization?: boolean, preHeaderValidations?: MiddlewareOptions, preBodyValidations?: MiddlewareOptions) {
        const authenticate = preAuthenticate || node.authenticate !== undefined || this._defaultAuthenticate;
        const authorization = preAuthorization || node.authenticate?.authorization !== undefined;
        const headerValidations = {...(preHeaderValidations || {}), ...(node.header || {})};
        const bodyValidations = {...(preBodyValidations || {}), ...(node.body || {})};
        const route = `${prefixRoute}${node.path.path}`;
        const method = node.method.toLowerCase() as unknown as keyof SwaggerRouter;

        let router: SwaggerRouter;
        if (this._existingPaths[route]) {
            router = this._existingPaths[route];
        } else {
            router = {};
            this._existingPaths[route] = router;
            this._swagger.paths[route] = router;
        }

        const routeObject: SwaggerRoute = {
            tags: preTags,
            produces: this._mimeType ? [this._mimeType] : undefined,
            consumes: this._mimeType ? [this._mimeType] : undefined,
            summary: node.description,
            parameters: [],
            responses: {
                "200": {
                    description: "Success!"
                },
                "400": {
                    description: "Bad Request: A field from a specific type is required"
                }
            }
        };

        for (const key in routeObject) {
            // @ts-ignore - this is fine
            if (routeObject[key] === undefined) {
                // @ts-ignore - this is fine
                delete routeObject[key];
            }
        }

        router[method] = routeObject;

        for (const key in headerValidations) {
            if (typeof headerValidations[key] === "string") {
                const type = headerValidations[key] as string;
                routeObject.parameters.push({
                    in: 'header',
                    name: key,
                    required: true,
                    type: this.normalizeType(type)
                });
            }
        }

        node.path.queryParameters.forEach(x => {
            routeObject.parameters.push({
                in: 'query',
                name: x.name,
                required: true,
                type: this.normalizeType(x.type)
            });
        });

        routeObject.parameters.push(this.generateBodySchema(bodyValidations));

        if (authorization) {
            routeObject.responses["401"] = {
                description: "Unauthorized: You are not authorized to access this resource"
            };
        }

        if (authenticate) {
            routeObject.responses["403"] = {
                description: "Forbidden: You are not allowed to access this resource"
            };
        }
    }

    private generateBodySchema(body: MiddlewareOptions): SwaggerParameter {
        return {
            in: 'body',
            name: 'body',
            required: true,
            schema: {
                type: 'object',
                properties: this.generateChildBodySchema(body)
            }
        };
    }

    private generateChildBodySchema(body: MiddlewareOptions): {[key: string]: unknown} {
        const schema: {[key: string]: unknown} = {};

        for (const key in body) {
            if (typeof body[key] === "string") {
                const type = body[key] as string;
                schema[key] = {
                    type: this.normalizeType(type)
                };
                
            } else if (typeof body[key] === "object") {
                const child: MiddlewareOptions = body[key] as unknown as MiddlewareOptions;
                schema[key] = {
                    type: 'object',
                    properties: this.generateChildBodySchema(child)
                };
            }
        }

        return schema;
    }

    private compileAuthBlockNode(node: AuthBlockNode) {
        if (node.isDefaultAccessPublic === false) {
            if (this._defaultAuthenticate) {
                Logger.fatal("Only one default authentication block can be defined.");
                throw new AbortError();
            }

            this._defaultAuthenticate = true;
        }

        const mode = node.options["mode"] as BearerAuthGenerationMode ?? BearerAuthGenerationMode.None;

        if (mode === BearerAuthGenerationMode.Basic || mode === BearerAuthGenerationMode.Full) {
            const withLogout = node.options["withLogout"] as boolean ?? false;
            const loginPath = node.options["loginPath"] as string ?? "/login";
            const loginSource = node.options["loginSource"] as "body"|"query"|"header" ?? "body";
            const usernameField = node.options["usernameField"] as string ?? "username";
            const passwordField = node.options["passwordField"] as string ?? "password";
            const logoutPath = node.options["logoutPath"] as string ?? "/logout";

            const loginRouter: SwaggerRouter = {
                post: {
                    tags: [node.name],
                    produces: ["text/plain"],
                    consumes: this._mimeType ? [this._mimeType] : undefined,
                    summary: "Logins the user",
                    parameters: [
                        {
                            in: loginSource,
                            name: usernameField,
                            required: true,
                        },
                        {
                            in: loginSource,
                            name: passwordField,
                            required: true,
                        }
                    ],
                    responses: {
                        "200": {
                            description: "Success!"
                        },
                        "400": {
                            description: "Bad Request: A field from a specific type is required"
                        },
                        "401": {
                            description: "Unauthorized: You are not authorized to access this resource"
                        },
                    },
                },
            };
            this._additionalRoutes[loginPath] = loginRouter;

            if (withLogout) {
                const logoutRouter: SwaggerRouter = {
                    post: {
                        tags: [node.name],
                        produces: ["text/plain"],
                        consumes: this._mimeType ? [this._mimeType] : undefined,
                        summary: "Logouts the user",
                        parameters: [
                            {
                                in: "header",
                                name: "Authorization",
                                required: true,
                                type: "string"
                            }
                        ],
                        responses: {},
                    },
                };
                this._additionalRoutes[logoutPath] = logoutRouter;
            }
        }
    }

    private handleMiddleware(node: MiddlewareNode) {
        if (node.name === "json") {
            this._mimeType = "application/json";
        }
    }

    private normalizeType(type: string): string {
        if (type === "int") {
            return "integer";
        } else if (type === "float") {
            return "number";
        } else if (type === "datetime" || type === "date" || type === "time") {
            return "string";
        }

        return type;
    }
}

interface SwaggerYaml {
    swagger: '2.0';
    info: SwaggerInfo;
    paths: {
        [key: string]: SwaggerRouter;
    };
}

interface SwaggerInfo {
    description: string;
    version: string;
    title: string;
}

interface SwaggerRouter {
    get?: SwaggerRoute;
    post?: SwaggerRoute;
    put?: SwaggerRoute;
    delete?: SwaggerRoute;
    patch?: SwaggerRoute;
    head?: SwaggerRoute;
    options?: SwaggerRoute;
}

interface SwaggerRoute {
    tags?: string[];
    produces?: string[];
    consumes?: string[];
    summary?: string;
    parameters: SwaggerParameter[];
    responses: {
        [key: string]: {
            description: string;
        };
    };
}

interface SwaggerParameter {
    in: "query"|"body"|"header";
    name: string;
    required: true;
    type?: string;
    schema?: {[key: string]: unknown};
}